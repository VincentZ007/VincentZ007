<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://VincentZ007.github.io/</id>
    <title>Vincent&apos;s Blog</title>
    <updated>2020-07-18T06:03:44.697Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://VincentZ007.github.io/"/>
    <link rel="self" href="https://VincentZ007.github.io/atom.xml"/>
    <subtitle>？？？？？？？？？？？？？？？？？？</subtitle>
    <logo>https://VincentZ007.github.io/images/avatar.png</logo>
    <icon>https://VincentZ007.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Vincent&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[笔记-2020/07/18]]></title>
        <id>https://VincentZ007.github.io/post/bi-ji-20200718/</id>
        <link href="https://VincentZ007.github.io/post/bi-ji-20200718/">
        </link>
        <updated>2020-07-18T09:26:04.000Z</updated>
        <content type="html"><![CDATA[<h1 id="顺序表与链表的比较">顺序表与链表的比较</h1>
<ol>
<li>存取方式<br>
顺序表可以顺序存取<strong>也可以</strong>随机存取，<br>
链表<strong>只能</strong>从表头顺序存取元素。</li>
<li>逻辑结构与物理结构<br>
采用顺序存储时，逻辑上相邻的元素，对应的物理存储位置<strong>也</strong>相邻。<br>
采用链式存储时，逻辑上相邻的元素，对应的物理存储位置<strong>不一定</strong>相邻，逻辑关系是用<strong>指针</strong>来表示的。</li>
<li>查找、插入和删除<br>
| null | 顺序表 | 链表 |<br>
| 查找 | O(n) | O(n) |<br>
| 插入 | O(n) | O(1) |<br>
| 删除 | O(n) | O(1) |</li>
<li>空间分配<br>
顺序表是静态空间分配，<br>
链表是动态空间分配。</li>
</ol>
<h1 id="实际应用中表的选取">实际应用中表的选取</h1>
<ol>
<li>基于存储考虑<br>
顺序表：可以估计线性表的长度或存储规模时采用。<br>
链表：不用事先知道存储规模，但链表的存储密度低。</li>
<li>基于运算考虑<br>
顺序表：经常访问链表中的元素时使用。<br>
链表：经常插入或者删除时使用。</li>
<li>基于环境考虑<br>
顺序表：直接采用数组，容易实现。<br>
链表：基于指针实现，相对较为繁琐。</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔记-2020/07/08]]></title>
        <id>https://VincentZ007.github.io/post/bi-ji-20200708/</id>
        <link href="https://VincentZ007.github.io/post/bi-ji-20200708/">
        </link>
        <updated>2020-07-08T08:10:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="双链表">双链表</h1>
<p>说明：单链表结点中只有一个指向其后继的指针，使得单链表只能从头结点依次顺序地向后访问。为了克服单链表只能从前往后的访问的缺陷，引入prior指针，使得链表可以向前访问。<br>
结构示意图：<br>
<img src="https://VincentZ007.github.io//post-images/1594188305261.png" alt="" loading="lazy"></p>
<h1 id="建表">建表</h1>
<pre><code>//尾插法建表
public DLinkList buildDLinkList(int[] arr) {
		DLinkList head = new DLinkList();
		head.next = null;
		head.prior = null;
		head.data = 0;
		DLinkList r = head;
		int count = 0;
		while (count &lt; arr.length) {
			DLinkList p = new DLinkList();
			p.data = arr[count++];
			p.next = r.next;
			p.prior = r;
			r.next = p;
			r = p;
		}
		return head;
	}
</code></pre>
<h1 id="插入删除">插入删除</h1>
<figure data-type="image" tabindex="1"><img src="https://VincentZ007.github.io//post-images/1594188336720.png" alt="" loading="lazy"></figure>
<pre><code>    //插入
	public DLinkList insert(DLinkList head,int posi,int value) {
		DLinkList p=head.next;
		int count=0;
		while (count&lt;posi) {
			p=p.next;
			count++;
		}
		DLinkList q=new DLinkList();
		q.data=value;
		q.next=p.next;
		q.prior=p;
		p.next.prior=q;
		p.next=q;
		return head;
	}

    //删除
    	public DLinkList delete(DLinkList head,int posi) {
		DLinkList p=head;
		int count=0;
		while (count&lt;posi) {
			p=p.next;
			count++;
		}
		p.next.next.prior=p;
		p.next=p.next.next;
		return head;
	}
</code></pre>
<h1 id="循环链表">循环链表</h1>
<h2 id="循环单链表">循环单链表</h2>
<figure data-type="image" tabindex="2"><img src="https://VincentZ007.github.io//post-images/1594188344719.png" alt="" loading="lazy"></figure>
<h2 id="循环双链表">循环双链表</h2>
<figure data-type="image" tabindex="3"><img src="https://VincentZ007.github.io//post-images/1594188351671.png" alt="" loading="lazy"></figure>
<h2 id="静态链表">静态链表</h2>
<figure data-type="image" tabindex="4"><img src="https://VincentZ007.github.io//post-images/1594188385094.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔记-2020/06/24]]></title>
        <id>https://VincentZ007.github.io/post/bi-ji-20200624/</id>
        <link href="https://VincentZ007.github.io/post/bi-ji-20200624/">
        </link>
        <updated>2020-06-24T18:21:41.000Z</updated>
        <content type="html"><![CDATA[<h1 id="单链表的各种函数">单链表的各种函数</h1>
<h3 id="获取单链表长度">获取单链表长度</h3>
<pre><code>public int findLength(LinkList list) {
		int count=0;
		while(true){
			count++;
			if(list.next==null)return count;
			list=list.next;
		}
	}

</code></pre>
<h3 id="或">或</h3>
<pre><code>	public int getLength(LinkList list) {
		int count=-1;
		while (list!=null) {
			list=list.next;
			count++;
		}
		return count;
	}
</code></pre>
<h3 id="查找链表中第一个值为e的结点">查找链表中第一个值为e的结点</h3>
<pre><code>public LinkList findEByValue(LinkList list,int e) {
		while(list!=null) {
			if(list.data==e) {
				return list;
			}
			list=list.next;
		}
		return null;
	}
</code></pre>
<h3 id="查找链表中第k个结点的值">查找链表中第k个结点的值</h3>
<pre><code>public LinkList findEByNum(LinkList list,int k) {
		if(getLength(list)&lt;k)
			return null;
		int count=0;
		while (count&lt;k) {
			list=list.next;
			count++;
		}
		return list;
	}
</code></pre>
<h3 id="颠倒单链表并输出">颠倒单链表并输出</h3>
<pre><code>public void printReverseLinkList(LinkList list) {
		LinkList head=list;
		LinkList p=list.next;
		LinkList q;
		list.next=null;
		while(p!=null) {
			q=p.next;
			p.next=head.next;
			head.next=p;
			p=q;
		}
		printLinkList(head);
	}
</code></pre>
<h3 id="去掉单链表中重复的值并返回一个删去重复值的单链表">去掉单链表中重复的值，并返回一个删去重复值的单链表</h3>
<pre><code>public LinkList deleteSame(LinkList list) {
		list=list.next;
		LinkList haha=new LinkList();
		int j=0;
		int len=getLength(list);
		int lenxixi=0;
		int[] arr=new int[100];
		for (int i = 0; i &lt; len; i++) {
			arr[list.data]++;
			list=list.next;
		}
		System.out.println();
		for (int i = 0; i &lt; arr.length; i++) {
			if(arr[i]!=0) {
				lenxixi++;
			}
		}
		int[] xixi=new int[lenxixi];
		for (int i = 0; i &lt; arr.length; i++) {
			if(arr[i]!=0) {
				xixi[j]=i;
				j++;
			}
		}
		haha = haha.TailBuildList(xixi);
		return haha;
	}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔记-2020/06/22]]></title>
        <id>https://VincentZ007.github.io/post/bi-ji-20200622/</id>
        <link href="https://VincentZ007.github.io/post/bi-ji-20200622/">
        </link>
        <updated>2020-06-22T21:09:02.000Z</updated>
        <content type="html"><![CDATA[<h1 id="单链表">单链表</h1>
<h2 id="尾插法建立单链表">尾插法建立单链表</h2>
<pre><code>	// 尾插法建立单链表
	public LinkList TailBuildList(int[] arr) {
		LinkList list = new LinkList();
		list.data = 0;
		list.next = null;

		LinkList r = list;
		int count = 0;
		while (count &lt; arr.length) {
			LinkList p = new LinkList();
			p.data = arr[count];
			p.next = r.next;
			r.next = p;
			r = p;
			count++;
		}
		return list;
	}
</code></pre>
<h2 id="头插法建立单链表">头插法建立单链表</h2>
<pre><code>	// 头插法建立单链表
	public LinkList HeadBuildList(int[] arr) {
		LinkList head = new LinkList();
		head.data = 0;
		head.next = null;

		int count = 0;
		while (count &lt; arr.length) {
			LinkList p = new LinkList();
			p.data = arr[count];
			p.next = head.next;
			head.next = p;
            count++;
		}
		return head;
	}
</code></pre>
<h2 id="插入">插入</h2>
<pre><code>	public LinkList insert(LinkList list,int k,int e) {
		LinkList p=list.next;
		int count=0;
		while (count&lt;k) {
			p=p.next;
			count++;
		}
		LinkList q=new LinkList();
		q.data=e;
		q.next=p.next;
		p.next=q;
		return list;
	}
</code></pre>
<h2 id="删除">删除</h2>
<pre><code>	public LinkList delete(LinkList list,int k) {
		int count=0;
		while (count&lt;k) {
			list=list.next;
			count++;
		}
		list.next=list.next.next;
		return list;
	}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔记-2020/06/20]]></title>
        <id>https://VincentZ007.github.io/post/bi-ji-20200620/</id>
        <link href="https://VincentZ007.github.io/post/bi-ji-20200620/">
        </link>
        <updated>2020-06-20T07:35:56.000Z</updated>
        <content type="html"><![CDATA[<hr>
<h1 id="顺序表题解">顺序表题解</h1>
<p>④删除<strong>有序</strong>顺序表中所有重复的值，使得表中所有元素的值均不相同。</p>
<pre><code>	//删除有序顺序表中的重复元素
	public void deleteSame() {
		for (int i = 0; i &lt; len-1; i++) {
			if(data[i]==data[i+1]) {
				delete(i+1);
				i--;
			}
		}
	}
</code></pre>
<p>⑤删除顺序表中所有重复的值，使得表中所有元素的值均不相同。</p>
<pre><code>	//删除顺序表中的重复元素
	public void deleteSame2() {
		
		int[] arr=new int[23];
		for (int i = 0; i &lt; len; i++) {
			arr[data[i]]++;
		}
		
		System.out.println();
		for (int i = 0; i &lt; arr.length; i++) {
			if(arr[i]!=0)
				System.out.print(i+&quot; &quot;);
		}
		
	}
</code></pre>
<h1 id="单链表">单链表</h1>
<p>定义：线性表的链式存储又称单链表。它是指通过一组<strong>任意</strong>的存储单元来存储线性表中的数据元素。</p>
<p>弱点：由于单链表的元素离散的分布在存储空间中，所以单链表是一种非随机存取得存储结构。即不能直接找到表中某个特定的结点。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔记-2020/06/17]]></title>
        <id>https://VincentZ007.github.io/post/bi-ji-20200617/</id>
        <link href="https://VincentZ007.github.io/post/bi-ji-20200617/">
        </link>
        <updated>2020-06-17T13:39:44.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-顺序表">一、顺序表</h1>
<p>##顺序表的实现</p>
<pre><code class="language-java">//顺序表
class SequenceList{
	int data[];
	int len;
}
</code></pre>
<h2 id="1-插入操作">1. 插入操作</h2>
<pre><code class="language-java">	//插入
	public boolean insert(int p,int k) {
		if(p&gt;len&amp;&amp;p&lt;0)
			return false;
		if(len&gt;data.length)
			return false;
		for (int i = len; i &gt; p; i--) {
			data[i]=data[i-1];
		}
		data[p]=k;
		len++;
		return true;
	}
</code></pre>
<h2 id="2-删除操作">2. 删除操作</h2>
<pre><code class="language-java">	//删除
	public boolean delete(int p) {
		if(p&lt;0&amp;&amp;p&gt;len) {
			return false;
		}
		if(len&gt;data.length) {
			return false;
		}
		for(int i=p;i&lt;len;i++) {
			data[i]=data[i+1];
		}
		len--;
		return true;
	}
</code></pre>
<h2 id="3-按值查找操作">3. 按值查找操作</h2>
<pre><code class="language-java">	//查找
	public int findElem(int k) {
		for (int i = 0; i &lt; len; i++) {
			if(data[i]==k)
				return i;
		}
		return 0;
	}
</code></pre>
<h2 id="4-时间复杂度">4. 时间复杂度</h2>
<figure data-type="image" tabindex="1"><img src="https://VincentZ007.github.io//post-images/1592379914573.png" alt="" loading="lazy"></figure>
<h2 id="题目巩固">题目巩固：</h2>
<p>①在一个长度为n的顺序表中删除第i个元素时，需要向前移动（）个元素。<br>
②找到顺序表中最小值，并打印；<br>
③将顺序表中所有元素逆置；<br>
④删除<strong>有序</strong>顺序表中所有重复的值，使得表中所有元素的值均不相同。<br>
⑤删除顺序表中所有重复的值，使得表中所有元素的值均不相同。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔记-2020/06/15]]></title>
        <id>https://VincentZ007.github.io/post/bi-ji-20200615/</id>
        <link href="https://VincentZ007.github.io/post/bi-ji-20200615/">
        </link>
        <updated>2020-06-15T10:21:49.000Z</updated>
        <content type="html"><![CDATA[<hr>
<h1 id="center数据结构center"><center>数据结构</center></h1>
<h2 id="center一-概要center"><center>一、概要</center></h2>
<h3 id="1-数据结构的基本概念">1、数据结构的基本概念</h3>
<p>① 数据：数据是计算机程序加工的原料。<br>
② 数据元素：是数据的基本单位。<br>
③ 数据项：是构成数据元素的最小单位。<br>
④ 数据对象：具有相同性质的数据元素的结合。<br>
⑤ 数据类型：是一个值得集合和定义一组操作的总称。<br>
⑥ 是相互之间存在一种或者多种特定关系的数据元素的集合。</p>
<h3 id="2-数据结构三要素">2、数据结构三要素</h3>
<p>① 数据的逻辑结构：逻辑结构是指数据元素之间的逻辑关系，即从逻辑关系上描述数据。 它与数据的存储无关，是独立于计算机的。<br>
② 数据的存储结构：存储结构是指数据结构在计算机中的表示（又称映像），也称物理结构。 它包括数据元素的表示和关系的表示。<br>
③ 数据的运算：施加在数据上的运算包括运算的定义和实现。</p>
<h2 id="center二-算法及评价center"><center>二、算法及评价</center></h2>
<h3 id="1-基本概念">1、基本概念</h3>
<p>① 算法效率的度量：通过时间复杂度和空间复杂度来描述的。</p>
<h3 id="2-时间复杂度和空间复杂度">2、时间复杂度和空间复杂度</h3>
<p>② 时间复杂度：某个语句在该算法中被重复执行的次数。<br>
③ 空间复杂度：为该算法所耗费的存储空间。</p>
<h2 id="center三-线性表center"><center>三、线性表</center></h2>
<p>概念：具有相同数据类型的n个数据元素的有限序列。<br>
L=(a1,a2,a3,...,an);<br>
<img src="https://VincentZ007.github.io//post-images/1592205057433.png" alt="" loading="lazy"><br>
1.顺序存储<br>
概念:用一组地址连续的存储单元依次存储线性表中的数据元素。</p>
<pre><code>typedef struct{
        int data[];
        int n;
}
</code></pre>
<p>2.链式存储(单链表、双链表、循环链表)</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔记-2020/6/14]]></title>
        <id>https://VincentZ007.github.io/post/bi-ji-2020614/</id>
        <link href="https://VincentZ007.github.io/post/bi-ji-2020614/">
        </link>
        <updated>2020-06-14T20:22:54.000Z</updated>
        <content type="html"><![CDATA[<ol>
<li>
<p>添加百度统计😁</p>
</li>
<li>
<p>MarkDown基本语法学习😆</p>
<hr>
</li>
</ol>
<pre><code>##1.标题
&gt; 兼容Html语法， 标题逐渐变小: \&lt;h1&gt;-\&lt;h5&gt;
&gt; Markdwon情法， 标题逐新变小:
&gt; #
&gt; ##
&gt; ###
&gt; ####
&gt; #####
&lt;h1&gt;月夜与客饮酒杏花下&lt;/h1&gt;
&lt;h5&gt;宋代:苏轼&lt;/h5&gt;

---

##2.换行
&gt; \&lt;br/&gt;

---

##3.字体样式
&gt; \*content*斜体
&gt; \**content**粗体
&gt; \***content***粗斜体

---

##4.分割线
\---
\***

---

##5.划掉线
~~划掉文字~~

   ---

##6.下划线
&lt;u&gt;下划文字&lt;/u&gt;

   ---

##7.无序列表
+ 无序列表
- 无序列表
* 无序列表

   ---

##8.有序列表
1. 第一列
2. 第二列

   ---

##9.嵌套模块
&gt;第一层
&gt;&gt;第二层
&gt;&gt;&gt;第三层

   ---

##10.链接
直接显示链接: &lt;https://www.baidu.com&gt;
隐藏链接: [百度](https://www.baidu.com)

   ---

##11.图片
![头像](https://photos-1258928558.cos.ap-guangzhou.myqcloud.com/avatar_1591965590089.jpeg)

   ---

##12.表格
|  表头   | 表头  |
|  ----  | ----  |
| 单元格  | 单元格 |
| 单元格  | 单元格 |

   ---

##13.[markdown语法链接](https://www.runoob.com/markdown/md-tutorial.html)
</code></pre>
<hr>
<p>##1.标题</p>
<blockquote>
<p>兼容Html语法， 标题逐渐变小: &lt;h1&gt;-&lt;h5&gt;<br>
Markdwon情法， 标题逐新变小:</p>
<h1 id=""></h1>
<h2 id="-2"></h2>
<h3 id="-3"></h3>
<h4 id="-4"></h4>
<h5 id="-5"></h5>
</blockquote>
<h1>月夜与客饮酒杏花下</h1>
<h5>宋代:苏轼</h5>
<hr>
<p>##2.换行</p>
<blockquote>
<p>&lt;br/&gt;</p>
</blockquote>
<hr>
<p>##3.字体样式</p>
<blockquote>
<p>*content*斜体<br>
**content*<em>粗体<br>
*<strong>content</strong></em>粗斜体</p>
</blockquote>
<hr>
<p>##4.分割线<br>
---<br>
***</p>
<hr>
<p>##5.划掉线<br>
<s>划掉文字</s></p>
<hr>
<p>##6.下划线<br>
<u>下划文字</u></p>
<hr>
<p>##7.无序列表</p>
<ul>
<li>无序列表</li>
</ul>
<ul>
<li>无序列表</li>
</ul>
<ul>
<li>
<p>无序列表</p>
<hr>
</li>
</ul>
<p>##8.有序列表</p>
<ol>
<li>
<p>第一列</p>
</li>
<li>
<p>第二列</p>
<hr>
</li>
</ol>
<p>##9.嵌套模块</p>
<blockquote>
<p>第一层</p>
<blockquote>
<p>第二层</p>
<blockquote>
<p>第三层</p>
</blockquote>
</blockquote>
</blockquote>
<hr>
<p>##10.链接<br>
直接显示链接: <a href="https://www.baidu.com">https://www.baidu.com</a><br>
隐藏链接: <a href="https://www.baidu.com">百度</a></p>
<hr>
<p>##11.图片<br>
<img src="https://photos-1258928558.cos.ap-guangzhou.myqcloud.com/avatar_1591965590089.jpeg" alt="头像" loading="lazy"></p>
<hr>
<p>##12.表格</p>
<table>
<thead>
<tr>
<th>表头</th>
<th>表头</th>
</tr>
</thead>
<tbody>
<tr>
<td>单元格</td>
<td>单元格</td>
</tr>
<tr>
<td>单元格</td>
<td>单元格</td>
</tr>
</tbody>
</table>
<hr>
<p>##13.<a href="https://www.runoob.com/markdown/md-tutorial.html">markdown语法链接</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔记-2020/06/10]]></title>
        <id>https://VincentZ007.github.io/post/bi-ji-20200610/</id>
        <link href="https://VincentZ007.github.io/post/bi-ji-20200610/">
        </link>
        <updated>2020-06-10T18:50:22.000Z</updated>
        <content type="html"><![CDATA[<p>##老师发的</p>
<ol>
<li>添加Valine评论系统：在主题/config.json中修改添加Valine相关源码；</li>
<li></li>
</ol>
<p>①在主题/templates/includes/中引入valine.ejs<br>
②在主题/templates/post.ejs中引入<br>
&lt;% if(typeof site.customConfig['valine']!=='undefined' &amp;&amp; site.customConfig['valine']) { %&gt;<br>
&lt;%- include('./includes/valine') %&gt;<br>
&lt;% } %&gt;<br>
3. Valine评论系统简介：https://valine.js.org/；<br>
4. Valine注册使用：https://github.com/DesertsP/Valine-Admin；<br>
5. Valine邮件绑定；使用教程https://www.antmoe.com/posts/2380732b/index.html<br>
6. 添加百度统计功能https://tongji.baidu.com/web/welcome/login<br>
教程https://kily-007.github.io/post/gridea-tian-jia-bai-du-tong-ji/</p>
<p>##笔记<br>
今天学习了给博客添加留言功能。<br>
这节课我先是注册了Valine账号（国际版），然后在Valine中创建了项目，添加了许多的环境变量：<br>
<img src="https://VincentZ007.github.io//post-images/1591783308001.png" alt="" loading="lazy"><br>
之后要在Gridea上添加留言功能，最开始的时候我选择的主题并没有自带Valine评论配置，所以就弄了半天，最后还是选择换了一个带Valine评论配置主题。<br>
然后需要用Hbuilder来修改一些源代码，添加一个单独的留言页，最终也是成功完成了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[笔记-2020/06/08]]></title>
        <id>https://VincentZ007.github.io/post/bi-ji-20200608/</id>
        <link href="https://VincentZ007.github.io/post/bi-ji-20200608/">
        </link>
        <updated>2020-06-08T10:11:49.000Z</updated>
        <content type="html"><![CDATA[<h2 id="学习内容">学习内容：</h2>
<ul>
<li>Github注册，远程仓库创建</li>
<li>Gridea博客搭建</li>
<li>卜算子网页访问次数统计</li>
<li>HbuildX安装，并查看 Gridea源码</li>
<li>Html，CSS，Js简介</li>
</ul>
<h2 id="作业">作业：</h2>
<ul>
<li>撰写“关于”界面的博客，内容为自我介绍</li>
</ul>
]]></content>
    </entry>
</feed>